
import React, { useState } from 'react';
import { Plus, Trash2, Save, Database, Video, LayoutGrid, Loader2, ChevronDown, ChevronRight, X, Tag, RefreshCw, ArrowLeft, PenTool, FolderOpen } from 'lucide-react';
import { CatalogCategory, CatalogVideo, VideoCategoryRef } from '../types';
import { supabase } from '../supabaseClient';
import { INITIAL_CATALOG_CATEGORIES, INITIAL_CATALOG_VIDEOS } from '../constants';

interface CatalogManagerProps {
  categories: CatalogCategory[];
  videos: CatalogVideo[];
  onSave: () => void;
}

const CatalogManager: React.FC<CatalogManagerProps> = ({ categories, videos, onSave }) => {
  const [isSaving, setIsSaving] = useState(false);
  const [view, setView] = useState<'dashboard' | 'edit_video'>('dashboard');
  
  // Category State
  const [newCategory, setNewCategory] = useState('');
  const [expandedCategory, setExpandedCategory] = useState<string | null>(null);
  
  // Subcategory State (Local state for input)
  const [newSubcategoryLabel, setNewSubcategoryLabel] = useState('');
  const [activeSubcatInputId, setActiveSubcatInputId] = useState<string | null>(null);

  // Video State
  const [currentVideo, setCurrentVideo] = useState<Partial<CatalogVideo>>({
      title: '', description: '', video_url: '', category_refs: []
  });
  
  // SQL schema for the catalog features.
  // Videos store a JSONB array 'category_refs' which links to category ID + subcategory ID.
  const repairSql = `
-- 1. Create tables if not exist
CREATE TABLE IF NOT EXISTS public.catalog_categories_shibari (
    id text PRIMARY KEY,
    label text,
    subcategories jsonb DEFAULT '[]'::jsonb,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

CREATE TABLE IF NOT EXISTS public.catalog_videos_shibari (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title text,
    description text,
    video_url text,
    category_refs jsonb DEFAULT '[]'::jsonb,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);

-- 2. Enable RLS
ALTER TABLE public.catalog_categories_shibari ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.catalog_videos_shibari ENABLE ROW LEVEL SECURITY;

-- 3. Policies
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'catalog_categories_shibari' AND policyname = 'Allow all') THEN
    CREATE POLICY "Allow all" ON public.catalog_categories_shibari FOR ALL USING (true) WITH CHECK (true);
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE tablename = 'catalog_videos_shibari' AND policyname = 'Allow all') THEN
    CREATE POLICY "Allow all" ON public.catalog_videos_shibari FOR ALL USING (true) WITH CHECK (true);
  END IF;
END $$;
  `.trim();

  // Logic: Seed
  // Resets the database tables to the initial state defined in constants.ts
  const handleSeed = async () => {
      if (!window.confirm("Это сбросит каталог к базовому состоянию (3 видео). Продолжить?")) return;
      setIsSaving(true);
      try {
          if (!supabase) throw new Error("No DB");
          
          // Clear existing
          await supabase.from('catalog_videos_shibari').delete().neq('id', 0);
          await supabase.from('catalog_categories_shibari').delete().neq('id', '0');

          const { error: catError } = await supabase.from('catalog_categories_shibari').insert(INITIAL_CATALOG_CATEGORIES);
          if (catError) throw catError;

          // Remove IDs to auto-generate
          const videosToInsert = INITIAL_CATALOG_VIDEOS.map(({ id, ...rest }) => rest);
          const { error: vidError } = await supabase.from('catalog_videos_shibari').insert(videosToInsert);
          if (vidError) throw vidError;

          alert("Каталог сброшен!");
          onSave();
      } catch (e: any) {
          console.error(e);
          alert(`Ошибка инициализации: ${e.message}\n\nВозможно, нужно обновить структуру БД. Скопируйте SQL ниже в Supabase SQL Editor:\n\n${repairSql}`);
      } finally {
          setIsSaving(false);
      }
  };

  // Logic: Random Generation
  // Useful for stress testing the catalog UI (Grid + Filtering)
  const handleGenerateRandom = async () => {
      if (!window.confirm("Создать 100 случайных видео? Таблица видео будет очищена.")) return;
      setIsSaving(true);
      try {
          if (!supabase) throw new Error("No DB");
          
          // 1. Clean Videos
          await supabase.from('catalog_videos_shibari').delete().neq('id', 0);

          // 2. Generate Data
          const prefixes = ['Kinbaku', 'Shibari', 'Semenawa', 'Hojojutsu', 'Gishiki', 'Nawashi', 'Karada', 'Teppo', 'Agura', 'Takate Kote', 'Futomomo', 'Ichinawa'];
          const suffixes = ['Technique', 'Practice', 'Flow', 'Safety', 'Review', 'Demo', 'Lab', 'Masterclass'];
          const descTerms = ['anatomy', 'rope handling', 'suspension safety', 'floorwork aesthetics', 'knot theory'];
          const videoUrl = 'https://www.youtube.com/watch?v=f7uVUa2_y1k';

          const newVideos: any[] = [];
          
          for (let i = 0; i < 100; i++) {
              const title = `${prefixes[Math.floor(Math.random() * prefixes.length)]} : ${suffixes[Math.floor(Math.random() * suffixes.length)]}`;
              const description = `This is a detailed video lesson covering ${descTerms[Math.floor(Math.random() * descTerms.length)]}.`;
              
              // Generate refs based on CURRENT categories in state
              const refs = categories.map(cat => {
                  const subs = cat.subcategories || [];
                  if (subs.length === 0) return null;
                  const randomSub = subs[Math.floor(Math.random() * subs.length)];
                  return {
                      categoryId: cat.id,
                      subcategoryId: randomSub.id
                  };
              }).filter(Boolean);

              newVideos.push({
                  title,
                  description,
                  video_url: videoUrl,
                  category_refs: refs
              });
          }

          // 3. Insert in chunks of 50 to avoid payload limits
          const chunkSize = 50;
          for (let i = 0; i < newVideos.length; i += chunkSize) {
              const chunk = newVideos.slice(i, i + chunkSize);
              const { error } = await supabase.from('catalog_videos_shibari').insert(chunk);
              if (error) throw error;
          }
          
          alert("100 видео успешно создано!");
          onSave();
      } catch (e: any) {
          console.error(e);
          alert(`Ошибка: ${e.message}\n\nЕсли ошибка 'column does not exist', выполните этот SQL:\n\n${repairSql}`);
      } finally {
          setIsSaving(false);
      }
  };

  const handleAddCategory = async () => {
      if (!newCategory.trim()) return;
      setIsSaving(true);
      try {
          const id = Math.random().toString(36).substr(2, 9);
          if (supabase) {
              await supabase.from('catalog_categories_shibari').insert([{ 
                  id, 
                  label: newCategory,
                  subcategories: [] 
              }]);
              setNewCategory('');
              onSave();
          }
      } catch (e) { alert("Ошибка добавления категории"); }
      finally { setIsSaving(false); }
  };

  const handleDeleteCategory = async (id: string) => {
      if (!window.confirm("Удалить категорию?")) return;
      setIsSaving(true);
      try {
          if (supabase) {
              await supabase.from('catalog_categories_shibari').delete().eq('id', id);
              onSave();
          }
      } catch (e) { alert("Ошибка удаления"); }
      finally { setIsSaving(false); }
  };

  const handleAddSubcategory = async (categoryId: string) => {
      if (!newSubcategoryLabel.trim()) return;
      setIsSaving(true);
      try {
          const category = categories.find(c => c.id === categoryId);
          if (!category || !supabase) return;

          const newSub = {
              id: Math.random().toString(36).substr(2, 9),
              label: newSubcategoryLabel
          };
          const updatedSubs = [...(category.subcategories || []), newSub];

          const { error } = await supabase
              .from('catalog_categories_shibari')
              .update({ subcategories: updatedSubs })
              .eq('id', categoryId);
          
          if (error) throw error;
          setNewSubcategoryLabel('');
          setActiveSubcatInputId(null);
          onSave();
      } catch (e: any) { alert("Ошибка: " + e.message); }
      finally { setIsSaving(false); }
  };

  const handleDeleteSubcategory = async (categoryId: string, subId: string) => {
      if (!window.confirm("Удалить подкатегорию?")) return;
      setIsSaving(true);
      try {
          const category = categories.find(c => c.id === categoryId);
          if (!category || !supabase) return;

          const updatedSubs = (category.subcategories || []).filter(s => s.id !== subId);

          const { error } = await supabase
              .from('catalog_categories_shibari')
              .update({ subcategories: updatedSubs })
              .eq('id', categoryId);
          
          if (error) throw error;
          onSave();
      } catch (e: any) { alert("Ошибка: " + e.message); }
      finally { setIsSaving(false); }
  };

  // --- Video Handlers ---

  const startEditVideo = (video?: CatalogVideo) => {
      if (video) {
          setCurrentVideo({ ...video });
      } else {
          setCurrentVideo({
              title: '',
              description: '',
              video_url: '',
              category_refs: []
          });
      }
      setView('edit_video');
  };

  const handleSaveVideo = async () => {
      if (!currentVideo.title || !currentVideo.video_url) {
          alert("Название и ссылка обязательны");
          return;
      }
      setIsSaving(true);
      try {
          if (!supabase) throw new Error("No DB");
          const payload = {
              title: currentVideo.title,
              description: currentVideo.description,
              video_url: currentVideo.video_url,
              category_refs: currentVideo.category_refs || []
          };

          if (currentVideo.id) {
              const { error } = await supabase.from('catalog_videos_shibari').update(payload).eq('id', currentVideo.id);
              if (error) throw error;
          } else {
              const { error } = await supabase.from('catalog_videos_shibari').insert([payload]);
              if (error) throw error;
          }
          onSave();
          setView('dashboard');
      } catch (e: any) { alert("Ошибка сохранения: " + e.message); }
      finally { setIsSaving(false); }
  };

  const handleDeleteVideo = async (id: number) => {
      if (!window.confirm("Удалить видео?")) return;
      setIsSaving(true);
      try {
          if (supabase) {
              await supabase.from('catalog_videos_shibari').delete().eq('id', id);
              onSave();
          }
      } catch (e) { alert("Ошибка удаления"); }
      finally { setIsSaving(false); }
  };

  // Logic: Tagging
  // Manages the relationship between a video and categories.
  // It ensures only unique pairs (Category + Subcategory) exist in the refs array.
  const toggleVideoCategoryRef = (categoryId: string, subcategoryId?: string) => {
      setCurrentVideo(prev => {
          const refs = prev.category_refs || [];
          const existsIndex = refs.findIndex(r => r.categoryId === categoryId && r.subcategoryId === subcategoryId);
          
          if (existsIndex >= 0) {
              // Remove
              return { ...prev, category_refs: refs.filter((_, i) => i !== existsIndex) };
          } else {
              // Add
              return { ...prev, category_refs: [...refs, { categoryId, subcategoryId }] };
          }
      });
  };

  // --- Render ---

  if (view === 'edit_video') {
      return (
          <div className="flex flex-col h-full space-y-6">
              <div className="flex items-center justify-between border-b border-neutral-800 pb-4">
                 <button onClick={() => setView('dashboard')} className="text-neutral-400 hover:text-white flex items-center gap-2">
                    <ArrowLeft className="w-4 h-4" /> Назад
                 </button>
                 <button onClick={handleSaveVideo} disabled={isSaving} className="bg-green-700 hover:bg-green-600 text-white px-6 py-2 rounded-lg font-medium flex items-center gap-2 disabled:opacity-50">
                    {isSaving ? <Loader2 className="w-4 h-4 animate-spin"/> : <Save className="w-4 h-4" />} Сохранить
                 </button>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-8 overflow-y-auto">
                  {/* Left: Metadata */}
                  <div className="space-y-4">
                      <div className="space-y-2">
                          <label className="text-xs text-neutral-500 font-bold uppercase">Название</label>
                          <input 
                              value={currentVideo.title || ''}
                              onChange={e => setCurrentVideo({...currentVideo, title: e.target.value})}
                              className="w-full bg-neutral-900 border border-neutral-800 rounded-lg px-4 py-3 text-white focus:border-red-600 outline-none"
                              placeholder="Название видео..."
                          />
                      </div>
                      <div className="space-y-2">
                          <label className="text-xs text-neutral-500 font-bold uppercase">Ссылка (YouTube)</label>
                          <input 
                              value={currentVideo.video_url || ''}
                              onChange={e => setCurrentVideo({...currentVideo, video_url: e.target.value})}
                              className="w-full bg-neutral-900 border border-neutral-800 rounded-lg px-4 py-3 text-white focus:border-red-600 outline-none"
                              placeholder="https://..."
                          />
                      </div>
                      <div className="space-y-2">
                          <label className="text-xs text-neutral-500 font-bold uppercase">Описание</label>
                          <textarea 
                              value={currentVideo.description || ''}
                              onChange={e => setCurrentVideo({...currentVideo, description: e.target.value})}
                              rows={5}
                              className="w-full bg-neutral-900 border border-neutral-800 rounded-lg px-4 py-3 text-white focus:border-red-600 outline-none resize-none"
                              placeholder="О чем это видео..."
                          />
                      </div>
                  </div>

                  {/* Right: Tagging */}
                  <div className="space-y-4">
                      <label className="text-xs text-neutral-500 font-bold uppercase flex items-center gap-2"><Tag className="w-3 h-3"/> Теги (Категории)</label>
                      <div className="bg-neutral-900 border border-neutral-800 rounded-xl p-4 space-y-4 max-h-[500px] overflow-y-auto">
                          {categories.map(cat => (
                              <div key={cat.id} className="space-y-2">
                                  <div className="flex items-center gap-2">
                                      <FolderOpen className="w-4 h-4 text-neutral-500" />
                                      <span className="font-bold text-white text-sm">{cat.label}</span>
                                  </div>
                                  <div className="flex flex-wrap gap-2 pl-6">
                                      {cat.subcategories?.map(sub => {
                                          const isSelected = currentVideo.category_refs?.some(r => r.categoryId === cat.id && r.subcategoryId === sub.id);
                                          return (
                                              <button
                                                  key={sub.id}
                                                  onClick={() => toggleVideoCategoryRef(cat.id, sub.id)}
                                                  className={`px-3 py-1 rounded-full text-xs border transition-all ${
                                                      isSelected 
                                                      ? 'bg-red-600 border-red-500 text-white' 
                                                      : 'bg-neutral-950 border-neutral-700 text-neutral-400 hover:border-neutral-500'
                                                  }`}
                                              >
                                                  {sub.label}
                                              </button>
                                          );
                                      })}
                                      {(!cat.subcategories || cat.subcategories.length === 0) && (
                                          <span className="text-xs text-neutral-600 italic">Нет подкатегорий</span>
                                      )}
                                  </div>
                              </div>
                          ))}
                      </div>
                  </div>
              </div>
          </div>
      );
  }

  // Dashboard View
  return (
    <div className="flex flex-col h-full space-y-6">
        {/* Toolbar */}
        <div className="flex justify-between items-center bg-neutral-900/50 p-4 rounded-xl border border-neutral-800">
            <div>
                <p className="text-white font-bold flex items-center gap-2"><LayoutGrid className="w-4 h-4"/> Управление каталогом</p>
                <p className="text-neutral-500 text-sm">Видео: {videos.length} | Категорий: {categories.length}</p>
            </div>
            <div className="flex gap-2">
                <button onClick={handleSeed} disabled={isSaving} className="bg-neutral-800 hover:bg-neutral-700 text-neutral-300 px-3 py-2 rounded-lg text-xs font-bold uppercase flex items-center gap-2 border border-neutral-700">
                    {isSaving ? <Loader2 className="w-3 h-3 animate-spin"/> : <Database className="w-3 h-3"/>} Сброс
                </button>
                <button onClick={handleGenerateRandom} disabled={isSaving} className="bg-neutral-800 hover:bg-neutral-700 text-neutral-300 px-3 py-2 rounded-lg text-xs font-bold uppercase flex items-center gap-2 border border-neutral-700">
                    <RefreshCw className="w-3 h-3"/> Генерация (100)
                </button>
                <button onClick={() => startEditVideo()} className="bg-red-700 hover:bg-red-600 text-white px-4 py-2 rounded-lg font-bold text-sm flex items-center gap-2">
                    <Video className="w-4 h-4" /> Добавить видео
                </button>
            </div>
        </div>

        <div className="flex-1 grid grid-cols-1 md:grid-cols-3 gap-6 overflow-hidden">
            
            {/* Left Column: Categories */}
            <div className="md:col-span-1 bg-neutral-900/30 border border-neutral-800 rounded-xl flex flex-col overflow-hidden">
                <div className="p-4 border-b border-neutral-800 bg-neutral-900/50">
                    <h3 className="font-bold text-white text-sm">Категории</h3>
                </div>
                
                <div className="flex-1 overflow-y-auto p-4 space-y-4">
                    {/* Add Category Input */}
                    <div className="flex gap-2">
                        <input 
                            value={newCategory}
                            onChange={(e) => setNewCategory(e.target.value)}
                            placeholder="Новая категория..."
                            className="flex-1 bg-neutral-950 border border-neutral-700 rounded px-2 py-1 text-sm text-white outline-none focus:border-red-500"
                            onKeyDown={e => e.key === 'Enter' && handleAddCategory()}
                        />
                        <button onClick={handleAddCategory} className="p-1.5 bg-neutral-800 hover:bg-white hover:text-black rounded text-neutral-400 transition-colors"><Plus className="w-4 h-4"/></button>
                    </div>

                    {/* Categories List */}
                    <div className="space-y-2">
                        {categories.map(cat => {
                            const isExpanded = expandedCategory === cat.id;
                            return (
                                <div key={cat.id} className="bg-neutral-950 border border-neutral-800 rounded-lg overflow-hidden">
                                    <div className="flex items-center justify-between p-2 hover:bg-neutral-900 cursor-pointer" onClick={() => setExpandedCategory(isExpanded ? null : cat.id)}>
                                        <div className="flex items-center gap-2 text-sm font-medium text-white">
                                            {isExpanded ? <ChevronDown className="w-3 h-3 text-neutral-500"/> : <ChevronRight className="w-3 h-3 text-neutral-500"/>}
                                            {cat.label}
                                            <span className="text-xs text-neutral-600">({cat.subcategories?.length || 0})</span>
                                        </div>
                                        <button onClick={(e) => { e.stopPropagation(); handleDeleteCategory(cat.id); }} className="text-neutral-600 hover:text-red-500 p-1"><Trash2 className="w-3 h-3"/></button>
                                    </div>

                                    {/* Subcategories Area */}
                                    {isExpanded && (
                                        <div className="border-t border-neutral-800 bg-black/20 p-2 space-y-2">
                                            {cat.subcategories?.map(sub => (
                                                <div key={sub.id} className="flex justify-between items-center pl-6 pr-2 py-1 bg-neutral-900/50 rounded text-xs text-neutral-300 group">
                                                    <span>{sub.label}</span>
                                                    <button onClick={() => handleDeleteSubcategory(cat.id, sub.id)} className="opacity-0 group-hover:opacity-100 text-neutral-600 hover:text-red-500"><X className="w-3 h-3"/></button>
                                                </div>
                                            ))}
                                            <div className="pl-6 flex gap-2 pt-1">
                                                <input 
                                                    value={activeSubcatInputId === cat.id ? newSubcategoryLabel : ''}
                                                    onChange={(e) => { setActiveSubcatInputId(cat.id); setNewSubcategoryLabel(e.target.value); }}
                                                    placeholder="Подкатегория..."
                                                    className="flex-1 bg-neutral-900 border border-neutral-800 rounded px-2 py-1 text-xs text-white outline-none focus:border-red-500"
                                                    onKeyDown={e => e.key === 'Enter' && handleAddSubcategory(cat.id)}
                                                />
                                                <button onClick={() => handleAddSubcategory(cat.id)} className="text-neutral-400 hover:text-white"><Plus className="w-3 h-3"/></button>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                </div>
            </div>

            {/* Right Column: Videos */}
            <div className="md:col-span-2 bg-neutral-900/30 border border-neutral-800 rounded-xl flex flex-col overflow-hidden">
                <div className="p-4 border-b border-neutral-800 bg-neutral-900/50 flex justify-between items-center">
                    <h3 className="font-bold text-white text-sm">Видео библиотека</h3>
                    <span className="text-xs text-neutral-500 bg-neutral-950 px-2 py-1 rounded border border-neutral-800">{videos.length} Items</span>
                </div>
                
                <div className="flex-1 overflow-y-auto p-4">
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-3">
                        {videos.map(video => (
                            <div key={video.id} className="bg-neutral-950 border border-neutral-800 rounded-lg p-3 flex flex-col gap-2 group hover:border-neutral-600 transition-colors">
                                <div className="flex justify-between items-start gap-2">
                                    <h4 className="font-bold text-white text-sm line-clamp-1 leading-tight">{video.title}</h4>
                                    <div className="flex gap-1 shrink-0 opacity-0 group-hover:opacity-100 transition-opacity">
                                        <button onClick={() => startEditVideo(video)} className="p-1.5 bg-neutral-800 text-neutral-300 rounded hover:text-white"><PenTool className="w-3 h-3"/></button>
                                        <button onClick={() => handleDeleteVideo(video.id)} className="p-1.5 bg-red-900/20 text-red-500 rounded hover:bg-red-900/40"><Trash2 className="w-3 h-3"/></button>
                                    </div>
                                </div>
                                <div className="flex flex-wrap gap-1 mt-auto">
                                    {(video.category_refs || []).slice(0, 3).map((ref, idx) => {
                                        const cat = categories.find(c => c.id === ref.categoryId);
                                        const sub = cat?.subcategories?.find(s => s.id === ref.subcategoryId);
                                        if (!sub) return null;
                                        return (
                                            <span key={idx} className="text-[9px] bg-neutral-900 text-neutral-400 px-1.5 py-0.5 rounded border border-neutral-800">
                                                {sub.label}
                                            </span>
                                        );
                                    })}
                                    {(video.category_refs?.length || 0) > 3 && (
                                        <span className="text-[9px] text-neutral-600 px-1">+{video.category_refs!.length - 3}</span>
                                    )}
                                </div>
                            </div>
                        ))}
                    </div>
                    {videos.length === 0 && <div className="text-center text-neutral-600 py-10">Видео не найдены</div>}
                </div>
            </div>
        </div>
    </div>
  );
};

export default CatalogManager;
